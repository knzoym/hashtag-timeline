// src/components/tabs/VisualTab.js - „Ç∞„É´„Éº„ÉóÂåñ‰øÆÊ≠£ÂÆåÂÖ®Áâà
import React, { useRef, useCallback, useState, useMemo } from "react";
import SearchPanel from "../ui/SearchPanel";
import { TimelineCard } from "../ui/TimelineCard";
import { EventCard } from "../ui/EventCard";
import { EventModal } from "../modals/EventModal";
import TimelineModal from "../modals/TimelineModal";
import { SmoothLines } from "../ui/SmoothLines";
import { EventGroupIcon, GroupTooltip, GroupCard } from "../ui/EventGroup";

import { useCoordinate } from "../../hooks/useCoordinate";
import { UnifiedLayoutSystem } from "../../utils/groupLayoutSystem";
import { YearMarkers } from "../ui/YearMarkers";
import { TimelineAxes } from "../ui/TimelineAxes";

import { TIMELINE_CONFIG } from "../../constants/timelineConfig";

import { FloatingUI } from "../ui/FloatingUI";
import { TimelineView } from "../views/TimelineView";
import { NetworkView } from "../views/NetworkView";

const VisualTab = ({
  // „Éá„Éº„Çø
  events = [],
  timelines = [],
  tempTimelines = [],
  user,
  isWikiMode,
  viewMode = "timeline", // timeline | network

  // App.js„Åã„Çâ„ÅÆÊìç‰ΩúÈñ¢Êï∞
  onEventUpdate,
  onEventDelete,
  onAddEvent,
  onTimelineUpdate,
  onCreateTimeline,
  onCreateTempTimeline,
  onDeleteTimeline,
  onDeleteTempTimeline,
  onEventClick,
  onTimelineClick,

  // Ë°®Á§∫Âà∂Âæ°
  highlightedEvents = [],
  searchTerm = "",
  onSearchChange,
  getTopTagsFromSearch,

  // „É¢„Éº„ÉÄ„É´ÔºàApp.js„ÅßÁÆ°ÁêÜÔºâ
  selectedEvent,
  selectedTimeline,
  onCloseEventModal,
  onCloseTimelineModal,

  // „Åù„ÅÆ‰ªñ
  hoveredGroup,
  setHoveredGroup,
  showPendingEvents = false,
}) => {
  const timelineRef = useRef(null);
  const isNetworkMode = viewMode === "network";

  // „Ç∞„É´„Éº„ÉóÁä∂ÊÖãÁÆ°ÁêÜ
  const [expandedGroups, setExpandedGroups] = useState(new Set());

  // Â∫ßÊ®ô„Ç∑„Çπ„ÉÜ„É†ÔºàÁµ±Âêà„Åï„Çå„ÅüuseCoordinateÔºâ
  const coordinates = useCoordinate(timelineRef);
  const {
    scale,
    panY,
    isDragging,
    getXFromYear,
    getYearFromX,
    handleWheel,
    handleMouseDown,
    resetToInitialPosition,
  } = coordinates;

  // „ÉÜ„Ç≠„Çπ„ÉàÂπÖË®àÁÆó
  const calculateTextWidth = useCallback((text) => {
    if (!text) return 60;
    return Math.min(Math.max(60, text.length * 8), 200);
  }, []);

  // Ëâ≤„ÇíÊöó„Åè„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞ÔºàËêΩ„Å°ÁùÄ„ÅÑ„Åü„Éà„Éº„É≥Áî®Ôºâ
  const getDarkerColor = useCallback((hslColor, darkenAmount = 30) => {
    if (!hslColor || !hslColor.startsWith("hsl")) return hslColor;

    const match = hslColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
    if (match) {
      const h = match[1];
      const s = Math.max(20, Math.min(50, parseInt(match[2]) - 15));
      const l = Math.max(20, parseInt(match[3]) - darkenAmount);
      return `hsl(${h}, ${s}%, ${l}%)`;
    }
    return hslColor;
  }, []);

  // Áµ±Âêà„É¨„Ç§„Ç¢„Ç¶„Éà„Éû„Éç„Éº„Ç∏„É£„Éº„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñ
  const layoutManager = useMemo(() => {
    if (!coordinates || !calculateTextWidth) return null;
    return new UnifiedLayoutSystem(coordinates, calculateTextWidth);
  }, [coordinates, calculateTextWidth]);

  // Ë°®Á§∫Áî®„ÅÆÁµ±ÂêàÂπ¥Ë°®„Éá„Éº„Çø
  const displayTimelines = useMemo(() => {
    if (isWikiMode) {
      const convertedTempTimelines = tempTimelines.map((tempTimeline) => ({
        ...tempTimeline,
        isVisible: true,
        type: "temporary",
      }));
      return [...timelines, ...convertedTempTimelines];
    }
    return timelines;
  }, [isWikiMode, timelines, tempTimelines]);

  // Âπ¥„Éû„Éº„Ç´„ÉºÁîüÊàê
  const yearMarkers = useMemo(() => {
    if (!getXFromYear) return [];

    const markers = [];
    const viewportWidth = window.innerWidth;

    // „Çπ„Ç±„Éº„É´„Å´Âøú„Åò„ÅüÂπ¥ÈñìÈöî
    let yearInterval;
    const adjustedScale = scale / 2.5;

    if (adjustedScale > 12) yearInterval = 1;
    else if (adjustedScale > 6) yearInterval = 2;
    else if (adjustedScale > 2) yearInterval = 5;
    else if (adjustedScale > 0.8) yearInterval = 10;
    else if (adjustedScale > 0.4) yearInterval = 50;
    else if (adjustedScale > 0.2) yearInterval = 100;
    else if (adjustedScale > 0.1) yearInterval = 200;
    else if (adjustedScale > 0.04) yearInterval = 500;
    else yearInterval = 1000;

    for (let year = -5000; year <= 5000; year += yearInterval) {
      const x = getXFromYear(year);
      if (x > -100 && x < viewportWidth + 100) {
        markers.push({
          key: year,
          x,
          year,
          fontSize: Math.max(8, Math.min(14, 10 + adjustedScale)),
        });
      }
    }
    return markers;
  }, [scale, getXFromYear]);

  // Âπ¥Ë°®Ëª∏Ë®àÁÆó
  const timelineAxes = useMemo(() => {
    if (!getXFromYear) return [];

    const visibleTimelines = displayTimelines.filter(
      (t) => t.isVisible !== false
    );
    const axes = [];

    visibleTimelines.forEach((timeline, index) => {
      // Âπ¥Ë°®„Å´Â±û„Åô„Çã„Ç§„Éô„É≥„Éà„ÇíÊ§úÁ¥¢
      const timelineEvents = events.filter((event) => {
        // timelineInfosÊñπÂºè
        if (
          event.timelineInfos?.some(
            (info) => info.timelineId === timeline.id && !info.isTemporary
          )
        ) {
          return true;
        }
        // eventIdsÊñπÂºè
        if (timeline.eventIds?.includes(event.id)) {
          return true;
        }
        return false;
      });

      // Âπ¥ÁØÑÂõ≤Ë®àÁÆó
      let minYear = 2020,
        maxYear = 2025;
      if (timelineEvents.length > 0) {
        const years = timelineEvents
          .map((e) => e.startDate?.getFullYear?.())
          .filter((y) => y && !isNaN(y));
        if (years.length > 0) {
          minYear = Math.min(...years);
          maxYear = Math.max(...years);
        }
      }

      // Â∫ßÊ®ôË®àÁÆó
      const startX = getXFromYear(minYear);
      const endX = getXFromYear(maxYear);
      const yPosition =
        TIMELINE_CONFIG.FIRST_ROW_Y() + index * TIMELINE_CONFIG.ROW_HEIGHT;

      axes.push({
        id: timeline.id,
        name: timeline.name,
        color: timeline.color || "#6b7280",
        yPosition,
        startX,
        endX,
        cardX: Math.max(20, startX - 150),
        eventCount: timelineEvents.length,
        timeline,
      });
    });

    return axes;
  }, [displayTimelines, events, getXFromYear]);

  // Áµ±Âêà„É¨„Ç§„Ç¢„Ç¶„Éà„Ç∑„Çπ„ÉÜ„É†„Å´„Çà„Çã„Ç§„Éô„É≥„ÉàÈÖçÁΩÆË®àÁÆó
  const layoutEventsWithGroups = useMemo(() => {
    if (!events || !layoutManager || !timelineAxes) {
      return { allEvents: [], eventGroups: [] };
    }

    try {
      const layoutResult = layoutManager.executeLayout(events, timelineAxes);

      console.log(
        `Áµ±Âêà„É¨„Ç§„Ç¢„Ç¶„ÉàÁµêÊûú: ${layoutResult.allEvents.length}„Ç§„Éô„É≥„Éà, ${layoutResult.eventGroups.length}„Ç∞„É´„Éº„Éó`
      );
      layoutResult.eventGroups.forEach((group) => {
        console.log(
          `„Ç∞„É´„Éº„Éó ${group.id}: ‰ΩçÁΩÆ(${group.position.x.toFixed(0)}, ${
            group.position.y
          }) ${group.events.length}„Ç§„Éô„É≥„Éà`
        );
      });

      return layoutResult;
    } catch (error) {
      console.error("„É¨„Ç§„Ç¢„Ç¶„ÉàË®àÁÆó„Ç®„É©„Éº:", error);
      return { allEvents: [], eventGroups: [] };
    }
  }, [events, timelineAxes, layoutManager]);

  // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÂ∞ÇÁî®„É¨„Ç§„Ç¢„Ç¶„ÉàË®àÁÆó
  const networkLayout = useMemo(() => {
    if (!isNetworkMode) return { events: [], connections: [] };

    console.log("üåê „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„É¨„Ç§„Ç¢„Ç¶„ÉàË®àÁÆóÈñãÂßã");
    const networkEvents = [];
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;

    // ÂêÑÂπ¥Ë°®„ÅÆ‰∏≠ÂøÉYÂ∫ßÊ®ô„ÇíË®àÁÆó
    const timelinePositions = displayTimelines
      .filter((t) => t.isVisible !== false)
      .map((timeline, index) => {
        const centerY =
          viewportHeight * 0.2 + (index + 1) * (viewportHeight * 0.15);
        return {
          id: timeline.id,
          name: timeline.name,
          color: timeline.color || "#6b7280",
          centerY: Math.min(centerY, viewportHeight * 0.8),
          timeline,
        };
      });

    // Âπ¥Ë°®„Åî„Å®„Å´„Ç§„Éô„É≥„Éà„ÇíÈÖçÁΩÆ
    timelinePositions.forEach((timelinePos, timelineIndex) => {
      const timelineEvents = events.filter((event) => {
        return (
          event.timelineInfos?.some(
            (info) => info.timelineId === timelinePos.id && !info.isTemporary
          ) || timelinePos.timeline.eventIds?.includes(event.id)
        );
      });

      if (timelineEvents.length === 0) return;

      // ÊôÇÁ≥ªÂàóÈ†Ü„Å´„ÇΩ„Éº„Éà
      const sortedEvents = [...timelineEvents].sort((a, b) => {
        const aYear = a.startDate ? a.startDate.getFullYear() : 0;
        const bYear = b.startDate ? b.startDate.getFullYear() : 0;
        return aYear - bYear;
      });

      // „Ç§„Éô„É≥„Éà„ÇíYËª∏Âë®„Çä„Å´ÈÖçÁΩÆÔºàÂÜÜÂºßÁä∂„Å´ÂàÜÊï£Ôºâ
      sortedEvents.forEach((event, eventIndex) => {
        const eventX = event.startDate
          ? getXFromYear(event.startDate.getFullYear())
          : viewportWidth / 2;

        // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÂ∞ÇÁî®„ÅÆYÂ∫ßÊ®ôË®àÁÆóÔºàÂπ¥Ë°®‰∏≠ÂøÉ„Åã„ÇâÊîæÂ∞ÑÁä∂„Å´ÈÖçÁΩÆÔºâ
        const angleRange = Math.PI * 0.6; // Á¥Ñ108Â∫¶„ÅÆÁØÑÂõ≤
        const startAngle = -angleRange / 2;
        const angle =
          sortedEvents.length > 1
            ? startAngle + (eventIndex / (sortedEvents.length - 1)) * angleRange
            : 0;

        const radiusVariation = 40 + (eventIndex % 3) * 20; // ÂçäÂæÑ„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥
        const eventY = timelinePos.centerY + Math.sin(angle) * radiusVariation;

        networkEvents.push({
          ...event,
          adjustedPosition: {
            x: eventX,
            y: Math.max(50, Math.min(eventY, viewportHeight - 100)),
          },
          calculatedWidth: calculateTextWidth(event.title || "") + 20,
          calculatedHeight: 40,
          timelineColor: timelinePos.color,
          timelineInfo: {
            timelineId: timelinePos.id,
            timelineName: timelinePos.name,
            timelineColor: timelinePos.color,
            networkPosition: { angle, radius: radiusVariation },
          },
          hiddenByGroup: false,
        });
      });

      console.log(
        `Âπ¥Ë°®„Äå${timelinePos.name}„Äç: ${timelineEvents.length}„Ç§„Éô„É≥„Éà„Çí„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÈÖçÁΩÆ`
      );
    });

    return { events: networkEvents, timelinePositions };
  }, [
    isNetworkMode,
    events,
    displayTimelines,
    getXFromYear,
    calculateTextWidth,
  ]);

  // „É¨„Ç§„Ç¢„Ç¶„ÉàÈÅ∏ÊäûÔºà„Çø„Ç§„É†„É©„Ç§„É≥ or „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÔºâ
  const currentLayout = useMemo(() => {
    if (isNetworkMode) {
      return {
        allEvents: networkLayout.events,
        eventGroups: [], // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„É¢„Éº„Éâ„Åß„ÅØ„Ç∞„É´„Éº„ÉóÂåñ„Åó„Å™„ÅÑ
      };
    }
    return layoutEventsWithGroups;
  }, [isNetworkMode, networkLayout, layoutEventsWithGroups]);

  // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÊé•Á∂öÁ∑ö„Éá„Éº„ÇøÁîüÊàêÔºà‰øÆÊ≠£ÁâàÔºâ
  const networkConnections = useMemo(() => {
    if (!isNetworkMode) return [];

    const connections = [];
    console.log("üåê „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„É¢„Éº„Éâ: Êé•Á∂öÁ∑öÁîüÊàêÈñãÂßã");

    // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„É¨„Ç§„Ç¢„Ç¶„Éà„ÅÆ„Ç§„Éô„É≥„Éà„Åã„ÇâÊé•Á∂öÁ∑ö„ÇíÁîüÊàê
    if (networkLayout.timelinePositions) {
      networkLayout.timelinePositions.forEach((timelinePos) => {
        const timelineEvents = networkLayout.events.filter(
          (event) => event.timelineInfo?.timelineId === timelinePos.id
        );

        console.log(
          `Âπ¥Ë°®„Äå${timelinePos.name}„Äç: ${timelineEvents.length}ÂÄã„ÅÆÊé•Á∂öÂèØËÉΩ„Ç§„Éô„É≥„Éà`
        );

        if (timelineEvents.length >= 2) {
          // „Ç§„Éô„É≥„Éà„ÇíÊôÇÁ≥ªÂàóÈ†Ü„Å´„ÇΩ„Éº„Éà
          const sortedEvents = [...timelineEvents].sort((a, b) => {
            const aYear = a.startDate ? a.startDate.getFullYear() : 0;
            const bYear = b.startDate ? b.startDate.getFullYear() : 0;
            return aYear - bYear;
          });

          // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÁî®„ÅÆÊé•Á∂ö„Éù„Ç§„É≥„ÉàÁîüÊàê
          const connectionPoints = sortedEvents.map((event) => ({
            x: event.adjustedPosition.x,
            y: event.adjustedPosition.y, // panY„ÅØÂæå„ÅßSmoothLines„ÅßÈÅ©Áî®„Åï„Çå„Çã
          }));

          connections.push({
            id: timelinePos.id,
            name: timelinePos.name,
            color: timelinePos.color,
            points: connectionPoints,
          });

          console.log(`  ‚Üí Êé•Á∂öÁ∑öËøΩÂä†: ${connectionPoints.length}„Éù„Ç§„É≥„Éà`);
        }
      });
    }

    console.log(
      `üåê „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÊé•Á∂öÁ∑öÁîüÊàêÂÆå‰∫Ü: ${connections.length}Êú¨„ÅÆÊé•Á∂öÁ∑ö`
    );
    return connections;
  }, [isNetworkMode, networkLayout]);

  // „Ç∞„É´„Éº„ÉóÁÆ°ÁêÜ
  const toggleEventGroup = useCallback((groupId) => {
    setExpandedGroups((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(groupId)) {
        newSet.delete(groupId);
      } else {
        newSet.add(groupId);
      }
      return newSet;
    });
  }, []);

  // „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº
  const handleEventDoubleClick = useCallback(
    (event) => {
      console.log("VisualTab: Event double click:", event.title);

      // „Ç§„Éô„É≥„Éà„ÅÆÊ≠£Ë¶èÂåñ
      const normalizedEvent = {
        ...event,
        id: event.id || `temp-${Date.now()}`,
        title: event.title || "Êñ∞Ë¶è„Ç§„Éô„É≥„Éà",
        description: event.description || "",
        startDate: event.startDate || new Date(),
        endDate: event.endDate || null,
        tags: event.tags || [],
        timelineInfos: event.timelineInfos || [],
      };

      if (onEventClick) {
        onEventClick(normalizedEvent);
      }
    },
    [onEventClick]
  );

  const handleAddEventAtPosition = useCallback(
    (clientX, clientY) => {
      if (isWikiMode) {
        alert(
          "Wiki„É¢„Éº„Éâ„Åß„ÅÆ„Ç§„Éô„É≥„ÉàËøΩÂä†„ÅØÊâøË™ç„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ„Ç§„Éô„É≥„ÉàÁ∑®ÈõÜ„Çø„Éñ„Åã„ÇâÁî≥Ë´ã„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
        );
        return;
      }

      if (onAddEvent && getYearFromX && timelineRef.current) {
        const rect = timelineRef.current.getBoundingClientRect();
        const relativeX = clientX - rect.left;
        const relativeY = clientY - rect.top;

        // „ÇØ„É™„ÉÉ„ÇØÂ∫ßÊ®ô„Åã„ÇâÂπ¥„ÇíË®àÁÆó
        const clickedYear = Math.round(getYearFromX(relativeX));

        // Êñ∞„Åó„ÅÑ„Ç§„Éô„É≥„Éà„ÅÆÊó•‰ªò„ÇíË®≠ÂÆö
        const eventDate = new Date();
        eventDate.setFullYear(clickedYear);

        onAddEvent({
          title: "Êñ∞Ë¶è„Ç§„Éô„É≥„Éà",
          startDate: eventDate,
          description: "",
          tags: [],
          position: { x: relativeX, y: relativeY },
        });

        console.log(
          `Â∫ßÊ®ô (${relativeX}, ${relativeY}) „Å´ ${clickedYear} Âπ¥„ÅÆ„Ç§„Éô„É≥„Éà„ÇíËøΩÂä†`
        );
      }
    },
    [onAddEvent, getYearFromX, isWikiMode]
  );

  const handleTimelineDoubleClick = useCallback(
    (e) => {
      // „Ç§„Éô„É≥„Éà„ÇÑ„Ç∞„É´„Éº„Éó‰ª•Â§ñ„ÅÆÂ†¥ÊâÄ„Åß„ÅÆ„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ
      if (
        !e.target.closest("[data-event-id]") &&
        !e.target.closest("[data-group-id]")
      ) {
        handleAddEventAtPosition(e.clientX, e.clientY);
      }
    },
    [handleAddEventAtPosition]
  );

  const handleCreateTimeline = useCallback(
    (timelineName) => {
      // ÂºïÊï∞„ÅßÂπ¥Ë°®Âêç„ÇíÂèó„ÅëÂèñ„Çã„ÄÅ„Åæ„Åü„ÅØsearchTerm„Åã„ÇâËá™ÂãïË®≠ÂÆö
      const finalTimelineName =
        timelineName || searchTerm.trim() || "Êñ∞„Åó„ÅÑÂπ¥Ë°®";

      if (isWikiMode) {
        if (onCreateTempTimeline) {
          onCreateTempTimeline(finalTimelineName);
        }
      } else {
        if (onCreateTimeline) {
          onCreateTimeline(finalTimelineName);
        }
      }
    },
    [onCreateTimeline, onCreateTempTimeline, isWikiMode, searchTerm]
  );

  console.log(`VisualTab ${isNetworkMode ? "Network" : "Timeline"} render:`, {
    events: events?.length || 0,
    timelines: displayTimelines?.length || 0,
    layoutEvents: layoutEventsWithGroups.allEvents?.length || 0,
    eventGroups: layoutEventsWithGroups.eventGroups?.length || 0,
    expandedGroups: expandedGroups.size,
    connections: networkConnections?.length || 0,
    scale: scale?.toFixed(2),
  });

  return (
    <div style={{ flex: 1, position: "relative", overflow: "hidden" }}>
      {/* „É°„Ç§„É≥„Çø„Ç§„É†„É©„Ç§„É≥Ë°®Á§∫„Ç®„É™„Ç¢ */}
      <div
        ref={timelineRef}
        style={{
          width: "100%",
          height: "100%",
          position: "relative",
          overflow: "hidden",
          cursor: isDragging ? "grabbing" : "grab",
          backgroundColor: "#f8fafc",
        }}
        onWheel={handleWheel}
        onMouseDown={handleMouseDown}
        onDoubleClick={handleTimelineDoubleClick}
      >
        {/* Âπ¥„Éû„Éº„Ç´„Éº */}
        <YearMarkers markers={yearMarkers} />
        {/* „É°„Ç§„É≥„Çø„Ç§„É†„É©„Ç§„É≥Á∑ö */}
        <div
          style={{
            position: "absolute",
            left: 0,
            right: 0,
            top: `${window.innerHeight * 0.3 + panY}px`,
            height: "3px",
            backgroundColor: "#374151",
            zIndex: 1,
          }}
        />
        {/* viewMode„Å´Âøú„Åò„Å¶ÊèèÁîª„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíÂàá„ÇäÊõø„Åà */}
        {isNetworkMode ? (
          <NetworkView
            networkLayout={networkLayout}
            networkConnections={networkConnections}
            panY={panY}
            highlightedEvents={highlightedEvents || []}
            onTimelineClick={onTimelineClick}
            handleEventDoubleClick={handleEventDoubleClick}
            calculateTextWidth={calculateTextWidth}
          />
        ) : (
          <>
            <TimelineAxes
              axes={timelineAxes}
              displayTimelines={displayTimelines}
              panY={panY}
              onTimelineClick={onTimelineClick}
              onDeleteTempTimeline={onDeleteTempTimeline}
              onDeleteTimeline={onDeleteTimeline}
            />
            <TimelineView
              layoutData={layoutEventsWithGroups}
              panY={panY}
              highlightedEvents={highlightedEvents || []}
              hoveredGroup={hoveredGroup}
              expandedGroups={expandedGroups}
              setHoveredGroup={setHoveredGroup}
              toggleEventGroup={toggleEventGroup}
              handleEventDoubleClick={handleEventDoubleClick}
              calculateTextWidth={calculateTextWidth}
            />
          </>
        )}
        {/* ÁèæÂú®Á∑ö */}
        <div
          style={{
            position: "absolute",
            left: `${getXFromYear(new Date().getFullYear())}px`,
            top: "0",
            height: "100%",
            borderLeft: "2px solid #f59e0b",
            pointerEvents: "none",
            opacity: 0.8,
            zIndex: 12,
          }}
        >
          <div
            style={{
              position: "absolute",
              left: "5px",
              top: "30px",
              fontSize: "11px",
              color: "#f59e0b",
              backgroundColor: "rgba(255,255,255,0.9)",
              padding: "2px 6px",
              borderRadius: "3px",
              fontWeight: "600",
            }}
          >
            ÁèæÂú® ({new Date().getFullYear()})
          </div>
        </div>
      </div>

      {/* ‚òÖ „Éï„É≠„Éº„ÉÜ„Ç£„É≥„Ç∞UI„Çí„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Å´ÁΩÆ„ÅçÊèõ„Åà */}
      <FloatingUI
        searchTerm={searchTerm}
        highlightedEvents={highlightedEvents}
        onSearchChange={onSearchChange}
        handleCreateTimeline={handleCreateTimeline}
        getTopTagsFromSearch={getTopTagsFromSearch}
        timelines={timelines}
        tempTimelines={tempTimelines}
        isWikiMode={isWikiMode}
        resetToInitialPosition={resetToInitialPosition}
        handleAddEventAtPosition={handleAddEventAtPosition}
      />

      {/* „É¢„Éº„ÉÄ„É´ÔºàApp.js„ÅßÁÆ°ÁêÜÔºâ */}
      {selectedEvent && (
        <EventModal
          event={selectedEvent}
          onClose={onCloseEventModal}
          onUpdate={onEventUpdate}
          onDelete={onEventDelete}
          isWikiMode={isWikiMode}
          timelines={displayTimelines || []}
        />
      )}

      {selectedTimeline && (
        <TimelineModal
          timeline={selectedTimeline}
          onClose={onCloseTimelineModal}
          onUpdate={onTimelineUpdate}
          onDelete={
            selectedTimeline?.type === "temporary"
              ? onDeleteTempTimeline
              : onDeleteTimeline
          }
          isWikiMode={isWikiMode}
          isTemporary={selectedTimeline?.type === "temporary"}
        />
      )}
    </div>
  );
};

export default VisualTab;
